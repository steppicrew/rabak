#!/usr/bin/perl

package Rabak::Doc::Tutorial;

# This module is actually a script that generates all tutorial files in "./tutorials".

# It's POD file also can be used to generate a combined Tutorial:
# perldoc Rabak::Doc::Tutorial;

use warnings;
use strict;

use Data::Dumper;

my $out_dir= "tutorial";

our %part= ();
my $part;
my $partn= 1;
while (<DATA>) {
    if (/^=head1\s+(\S+)\s+(.*)/) {
        $part= substr($1, 0, 8) eq "TUTORIAL" ? sprintf("%02d", $partn++) : $1;
        $part{$part}= [ $2, '' ];
        next;
    }
    $part{$part}[1] .= $_ if $part;
}

# print Dumper(\%part); die;

my $toc= @{ $part{'INTRO'} }[1];

sub expand_body {
    my $body= shift;
    my $n= shift;
    my $no_code= shift || 0;

    $body =~ s/^\s+\n|\n\s+$//gs;

    my $state= 0;
    my $contents= "";
    for (split(/\n/, $body)) {
        my ($indent, $line)= ($1, $2) if /^(\s*)(.*)/;

        if ($no_code || $state == 2 || (!$indent && $line)) {

            $state= 2 if $state == 1;

            if (/^=head\d\s+(.*)/) {
                $contents .= "#\n"
                    . "# $1\n"
                    . "# " . ("-" x length($1)) . "\n";
                next;
            }
            next if /^=/;
            s/utorial\d/utorial$n/g;
            $contents .= "# $_\n";
            next;
        }
        next if /^=/;
        if (!$line) {
            $contents .= "\n";
            next;
        }
        $line =~ s/utorial\d/utorial$n/g;
        $indent =~ s/^\s\s//;

        # Decrease original indentiation by two
        $indent =~ s/^\s\s\s\s/  /;
        $contents .= "$indent$line\n";
        $state= 1 if $state == 0;
    }
    return $contents;
}

for my $n (sort { $a cmp $b } keys %part) {

    next if $n =~ /[^\d]/;

    my ($title, $body)= @{ $part{$n} };

    $toc .= "rabak.tutorial$n.cf: $title\n";
    $title= "Tutorial $n: $title";

    my $contents=
        expand_body(@{ $part{'COMMON_HEAD'} }[1], $n)
        . "\n\n"
        . "#" x length($title) . "######\n"
        . "#  $title  #\n"
        . "#" x length($title) . "######\n"
        . expand_body($body, $n)
        . expand_body(@{ $part{'COMMON_TAIL'} }[1], $n, 1)
    ;

    my $fout;
    open $fout, ">$out_dir/rabak.tutorial$n.cf" or die "Can't write rabak.tutorial$n.cf";
    print $fout $contents;
    close $fout;
}

# Remove old tutorials
while (-e "$out_dir/rabak.tutorial$partn.cf") {
    unlink "$out_dir/rabak.tutorial$partn.cf";
    $partn++;
}

my $fout;
open $fout, ">$out_dir/TABLE_OF_CONTENTS" or die "Can't write TABLE_OF_CONTENTS";
print $fout $toc;
close $fout;

__DATA__


=head1 INTRO

The tutorial files build on one another. If you don't understand a certain feature,
please look at the previous example.


=begin EXTRA


=head1 COMMON_HEAD

=head2 Annotated rabak tutorial configuration file

These configuration values are common to all tutorials:

  switch.verbose = 4
  switch.logging = 1


=head1 COMMON_TAIL

=head2 Further information

For more documentation, try 'rabak doc'.

To find out how b<rabak> sees this file, type '../rabak -c rabak.tutorial1.cf conf'.

(This file was generated by Rabak::Doc::Tutorial.
Changes to this file are useless.
To read the whole tutorial in one file, type 'rabak tutorial'.)


=end EXTRA


=head1 TUTORIAL1: Quick start! A Minimal Configuration

  tutorial.title = Tutorial1
  tutorial.source = tutorial/source
  tutorial.target = tutorial/target


=head2 Explanation

Running
  ../rabak -c rabak.tutorial1.cf conf
will produce following output:

  Available backup sets in "tutorial/rabak.tutorial1.cf":
    tutorial - Tutorial1, backs up "tutorial/source" to "tutorial/target"

b<Rabak> sees one backup set named 'tutorial', which will backup all files
from the directory 'tutorial/source' into the directory 'tutorial/target'.

Try this by running
  ../rabak -c rabak.tutorial1.cf backup tutorial

This will result in something like following output:
  INFO:    Rabak Version 0.6rc4
  INFO:    Backing up source '&source'
  INFO:    Backup start at 2007-07-30 18:01:30: tutorial, 2007-07-30, Tutorial1
  INFO:    Running: rsync -a --hard-links --filter=". /tmp/fSmfte1Dwk" --stats --verbose
                        "(some path)/tutorial/source/" "(some path)/tutorial/target/2007-07.tutorial/2007-07-30"

You'll find your backup in 'tutorial/target/2007-07.tutorial/2007-07-30'.


=head1 TUTORIAL1: Excluding specific files

  tutorial.title = Tutorial1
  tutorial.source = tutorial/source
  tutorial.target = tutorial/target
  tutorial.exclude = *.bak *.~

TBD!


=head1 TUTORIAL1: Multiple Backup Sets; Variables Basics

  target_path= tutorial/target

  exclude_files=
        *.bak
        *.~

  exclude= $exclude_files /tmp

  tutorial_full.title = Full Backup
  tutorial_full.source = tutorial/source
  tutorial_full.target = $target_path
  tutorial_full.exclude = $exclude

  tutorial_home.title = Backup Home Directory
  tutorial_home.source = tutorial/source/home
  tutorial_home.target = $target_path
  tutorial_home.exclude = $exclude

Variables are defined in a simple 'key=value' manner.
Here, 'target_path' is assigned the value 'tutorial/target'.

The 'exclude_files' value has a multi-line assignment.
An expression may be extended across multiple lines by indenting them.
The result is equal to 'exclude= *.bak *.~' but has an increased legibility.

Finally, the 'exclude' value uses the 'exclude_files' value, the result being
the same as 'exclude= *.bak *.~ /tmp'.

TBD!


=head1 TUTORIAL1: Simple Mount Points

  target_base = tutorial/target

  mount1.device = /dev/sda1
  mount1.directory = $target_base
  mount1.unmount = 1

  mount2.device = /dev/sdb1
  mount2.directory = $target_base
  mount2.unmount = 1

  # Backup set "Tutorial1 A"
  # The [tutorial1_a] sets the scope to "tutorial1_a". All assignments are now inside this scope.

  [tutorial1_a]
  title = Tutorial1 A
  source.path = tutorial/source
  target.path = tutorial/target
  target.mount = &mount1

  # Backup set "Tutorial1 B"
  # The [] clears the scope. Unlike "tutorial1_a" the scope must be written explicitly.

  []
  tutorial1_b.title = Tutorial1 B
  tutorial1_b.source.path = tutorial/source
  tutorial1_b.target.path = tutorial/target
  tutorial1_b.target.mount = &mount1 &mount2

TBD!


=head1 TUTORIAL1: Include Files; Target Groups

  target_base = tutorial/target

  INCLUDE ../rabak.std.cf

  mount1.device = /dev/sda[1-4]
  mount1.directory = $target_base
  mount1.unmount = 1

  [tutorial]
  title = Tutorial1
  source.path = tutorial/source
  target.path = tutorial/target
  target.mount = &mount1
  target.group = day-of-week
  exclude = *.bak *.~

TBD!


=head1 TUTORIAL1: Backing up databases

  switch.pretend = 1
  tutorial_target = tutorial/target

  # Some external device

  mount_external.device= /dev/sda1
  mount_external.directory= /mnt/external

  # Postgresql Database

  [tutorial_pg]
  title = Databases of tutorial
  source.path = pgsql://vbulletin,postnuke
  source.user = *default*
  source.password = secret
  target = $tutorial_target
  # target.path = $target_base/postgres
  keep = 3

  # MySql Database

  [tutorial_mysql]
  title = Mysql-DBs
  source.path = mysql://*
  source.user = mysql_user
  source.password = secret
  source.mount = &mount_external
  target = $tutorial_target
  # target.path = $target_base/mysql
  keep = 3

TBD!


=head1 TUTORIAL1: Multiple Sources per Backup Set

TBD!


=head1 TUTORIAL1: Unsing a Samba Mount Point as Source

  smb_dir = /mnt/samba/e
  smb_user= backup
  smb_password = secret

  # If you want to leave this configuration file readable for others, you can put
  # passwords in a different file and include it. E.g.: contents rabak.secret.cf:
  # smb_password = secret
  #
  # Then, to include rabak.secret.cf add the following line to this file:
  # INCLUDE rabak.secret.cf

  mount_smb_server.type= cifs
  mount_smb_server.device= //smb_server/e$
  mount_smb_server.directory= $smb_dir
  mount_smb_server.opts= "username=$smb_user,password=$smb_password,ro"
  mount_smb_server.unmount= 1

  tutorial_target.path = tutorial/target

  tutorial.title = Gesamtsystem
  tutorial.source.path = tutorial/source
  tutorial.target = &tutorial_target
  tutorial.mount = &mount_smb_server


=head1 TUTORIAL1: Backup from remote to local

TBD!


=head1 TUTORIAL1: Backup from local to remote

To backup to a remote target, you must provide two additional information to the target object: user and host.
B<rabak> at the moment supports key authentification, so you may have to add a authorised key on the target machine.
User/password support is tricky because you can't supply a password to ssh because of security reasons.

Once you have a working key authentification, you can specify the same variables to remote targets as to local targets.
For example, you can specify mount points, and rabak will do the right thing.

  # Setup local source
  [tutorial_local_source]
  path = tutorial/source

  # Setup local target
  [tutorial_local_target]
  path = tutorial/target
  host = some.host.name
  user = username.on.host
  mount.device = /dev/dev.on.remote.host
  mount.directory = /mnt/path/on.remote.host
  mount.umount = 1

  [tutorial_remote_target]
  group = tutorial
  discfree_threshold = 10%

  [tutorial]
  title = From local to remote
  source = &tutorial_local_source
  target = &tutorial_remote_target


=head1 TUTORIAL1: Backup from remote to remote

Remote to remote backup is essentially the same to local to remote.
Just specify an user and a host for the source and the target object and you're done.

  # Setup local source
  [tutorial_remote_source]
  path = /home/
  host = some.host.name
  user = username.on.host

  # Setup remote target
  [tutorial_remote_target]
  path = /rabak
  host = some.host.name
  user = username.on.host
  mount.device = /dev/dev.on.remote.host
  mount.device = /mnt/path/on.remote.host
  mount.umount = 1

  # specify a LOCAL directory to temporarily store files for the remote system (eg. database dumps)
  [tutorial_remote_target]
  tempdir = /path/for/temporary/files/on.local.host
  group = tutorial
  discfree_threshold = 10%

  [tutorial]
  title = From remote to remote
  source = &tutorial_remote_source
  target = &tutorial_remote_target


=head1 TUTORIAL1: Variables in depth

Variables are defined in a simple 'key=value' manner. E.g., the code

  server1= lisa

assigns the string 'lisa' to the variable 'server1'.

Variables can be clustered in objects simply by adding a name and a
dot in front of a variable name. Examples:

=over

=item Tutorial A

  mount1.title= My Mount Point
  mount1.path= /mnt/data

  lisa.title= Server "Lisa"
  lisa.mount_data.title= One of Lisa's Mount Points
  lisa.mount_data.path= /mnt/data

=back

Here, 'mount1' and 'lisa.mount1' are objects that contain simple variables.
'lisa' is an object containing a variable 'title' and an object 'mount_data'.

There are two ways in using a variable: substitution or binding.
Here are examples for substitution:

=over

=item Tutorial A, continued

  mount2= $mount1
  mount2.title= Copy of the "mount1" Mount Point

  bart.title= Server "Bart"
  bart.mount_data= $lisa.mount_data
  bart.mount_data.title= Now it's Bart's Mount Point

=back

The b<$>-Sign followed by a variable name is substituted by the value of that variable.
The above assignments will result in the following values:

  mount2.title= Copy of the "mount1" Mount Point
  mount2.path= /mnt/data

  bart.title= Server "Bart"
  bart.mount_data.title= Now it's Bart's Mount Point
  bart.mount_data.path= /mnt/data

Binding: TBD

Variables with a b<&> sigil are "bound variabled" and treated differently.
They act more than references and are assigned at time of use.
The idea is that you can set up a variable with a reference to anonther variable that is defined later in the configuration file.
This is mostly useful for common setups that are put into include-files.
It was actually introduced to support "std_exclude = &exclude", allowing the user to define "exclude" later on.
So, the standard include file needs it, you probably won't need it often.

=over

=item Tutorial B

  b.x = 1
  b.y = 2

  a = $b
  a.z= 3

  # c = &b
  # c.z= 3      # Won't work!

=back

TBD!

=head2 EOF
